### 프로세스

정적인 프로그램을 실행시켜 동적으로 변할 때, 프로그램이 돌아가고 있는 상태

### 스레드

하나의 프로세스에서 동시에 진행되는 작업들

### 화살표 함수와 일반 함수

- 화살표 함수
  - this에 바인딩할 객체가 정적으로 결정되는 것
  - 렉시컬 this에 따라 언제나 상위 this로 결정된다.
  - 콜백 함수에서 편리하게 사용된다.
- 일반 함수
  - this에 바인딩할 객체가 동적으로 결정되는 것

\*바인딩 : 식별자와 값을 연결하는 과정

### ES6에 추가된 문법

1. 변수 선언 (let, const)
2. 탬플릿 리터럴
3. 구조분해 할당
4. class
5. module
6. 화살표 함수

### 이벤트 루프

콜스택에 실행될 컨텍스트가 비어있을 때 콜백 큐로 부터 옮겨와 실행 가능하도록 하는 것

### async / defer

- async
  - HTML 렌더링 중 js를 다운로드가 완료되면 다운된 js 부터 실행
- defer
  - HTML 렌더링 중 js 다운로드가 완료 되더라도 HTML 렌러링이 끝난 후 실행

\*defer를 더 선호하는 이유?

렌더링 시간 외에 실행되며, 동기 스크립트를 차단할 수 없기 때문

### require / import

- require
  - commonJS 기반의 node.js에서 사용됨
- import
  - ES6에서만 사용
  - 필요한 모듈 부분만 사용할 수 있어 더 선호됨

### virtual DOM

페이지 렌더링 후 이벤트 발생시 이벤트가 발생된 부분에 가상돔을 렌더링하여 기존 DOM과 비교후 변경 된 DOM만 업데이트 하는 것

### OOP

객체지향 프로그래밍

- 장점
  - 코드 재사용성 높음
  - 유지보수 쉬움
  - 상속을 통한 확장 가능
- 단점
  - 처리 속도 느림
  - 객체가 많아지면 그만큼 용량도 커짐
- 특징
  - 캡슐화
  - 상속
  - 클래스
  - 객체

### 비동기 동작을 다루기 위한 패턴

- Promise
  - 콜백지옥에 빠질 수 있음
  - .catch()문으로 에러 핸들링 가능
- async/await
  - try/catch문으로 에러 핸들링
  - 코드가 길어질수록 가독성이 좋아짐

### useMemo vs useCallBack

- useMemo - 메모리제이션된 값을 반환
- useCallback - 메모리제이션된 함수를 반환

## JWT

Json Wet Token

사용자의 인증 정보가 담겨져 있는 토큰

- 기존 토큰은 DB에 저장했기에 서버 확장 어려움
- 인증 정보가 토큰 자체에 담겨있기에 정보를 저장해둘 필요가 없음

### React hook

함수형 컴포넌트로 클래스형 컴포넌트 기능을 사용할수 있게 하는 것

- 상태값 관리
- custom hook 생성가능
- 재사용성 가능한 로직

### 클래스형 컴포넌트 vs 함수형 컴포넌트

- 클래스형
  - render()가 필수
  - 상태저장 가능
- 함수형
  - return 필요
  - 메모리 자원 적음
  - hook 생성가능
  - 선언하기 편리

### SPA

하나의 페이지에 필요한 리소스를 처음에 전부 다운 받는 것

- 페이지 이동시 변경되는 부분만 받아서 업데이트 하므로 새로고침이 발생하지 않음
- 이동속도 빠름
- 첫 렌더링에 전부 받기 때문에 초기 구동속도 느림
- seo 불리

### 호이스팅

자바스크립트 실행 전 함수 내에 있는 선언들을 모두 끌어올려 해당 함수 유효 범위 최상단에 선언하는 것

- var 선언과 함수 선언문에만 호이스팅이 일어남

### CSR vs SSR

- CSR
  - 렌더링이 클라이언트쪽에서 일어남
  - 렌더링 시간 느림
- SSR
  - 서버에서 렌더링 준비가 끝난 상태로 클라이언트로 전달
  - 렌더링 시간 빠름
  - 서버 자원 더 많이 사용

### this

자신이 속한 객체나 자신이 생성한 인스턴스를 가리키는 자기참조변수

- 자바스크립트 엔진에 의해 암묵적으로 생성
- 코드 어디서든 참조 가능
- 전역에서 사용할 경우 window 참조 (엄격 모드 개발시 undefined)
